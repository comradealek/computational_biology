/**********************************************************************
 * global alignment for match, mismatch, and indel scores, and a file *
 * myAlign.c                                                          *
 * Aleksandr Means                                                    *
 **********************************************************************/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

//#define DEBUG

void globalAlignment(char *, char *, int, int, int, char **);

#define SEEN    0x8
#define LEFT    0x4
#define UPLEFT  0x2
#define UP      0x1



int main(int argc, char ** argv) {
  // early return if there aren't enough arguments
  if (argc != 5) return 0;

  // convert first 3 arguments to numbers
  int match = atoi(argv[1]);
  int mismatch = atoi(argv[2]);
  int indel = atoi(argv[3]);

  char * s = NULL;   // the S string, and the pointer to the entire char buffer
  FILE * pFile = fopen(argv[4], "r"); // pointer to the given file
  if (pFile == NULL) {
    fprintf(stderr, "error reading file at %s\n", argv[4]);
    return 1;
  }

  fseek(pFile, 0L, SEEK_END);
  size_t fsize = ftell(pFile); // the size of the file
  fseek(pFile, 0L, SEEK_SET);

  // We will now read the file into the text string
  s = malloc(fsize);
  char * t = NULL; // pointer to the T string
  char * next = s; // pointer to the next position in the string to read the file line into

  while (!feof(pFile)) {
    // the upper bound to read characters into the text string
    size_t n = fsize - (next - s); 

    // read the next file line into the text string at 'next'
    getline(&next, &n, pFile);

    // find the next instance of \n, \r, >, or ';', and set that to next
    // This will have the effect of overwriting the string starting at any
    // of these characters. This will erase comments, and will remove the 
    // carriage returns or newline characters.
    next = strpbrk(next, "\n\r>;");

    // if the S string has had data read into it and we see a comment, then we start reading
    // into the T string. Note that T is just a pointer into the buffer at S.
    if ((next[0] == '>' || next[0] == ';') && !t && s != next) {
      next[0] = 0;
      next += 1;
      t = next;
    }
  }
  
  // sets the final newline/carriage return to 0 if it exists.
  if (next) next[0] = 0;

  char * align = NULL; // where the alignment text will be placed after the function is run
  globalAlignment(s, t, match, mismatch, indel, &align);

  fprintf(stdout, "%s\n", align);
  if (align) free(align);
  free(s);
  return 0;
}

void globalAlignment(char * S, char * T, int match, int mismatch, int indel, char ** ret) {
  // get the number of characters in S and T
  size_t S_n = strlen(S);
  size_t T_n = strlen(T);

  // create the V matrix
  int V[S_n + 1][T_n + 1];
  for (int x = 0; x < S_n + 1; x++) {
    for (int y = 0; y < T_n + 1; y++) {
      if (x == 0 && y == 0) {
        V[x][y] = 0;
      } else if (x == 0) {
        V[x][y] = V[x][y - 1] + indel;
      } else if (y == 0) {
        V[x][y] = V[x - 1][y] + indel;
      } else {
        int u = V[x - 1][y] + indel;
        int l = V[x][y - 1] + indel;
        int ul = V[x - 1][y - 1] +  (S[x - 1] == T[y - 1] ? match : mismatch);
        V[x][y] = (u > l ? (u > ul ? u : ul) : (l > ul ? l : ul));
      }
    }
  }

#ifdef DEBUG
  // Print out the V matrix for debugging
  fprintf(stdout, " % 4c", '_');
  for (int y = 0; y < T_n + 1; y++) 
    fprintf(stdout, "% 4c", T[y]);
  fprintf(stdout, "\n");
  for (int x = 0; x < S_n + 1; x++) {
    if (x == 0) fprintf(stdout, "_");
    else fprintf(stdout, "%c", S[x - 1]);
    for (int y = 0; y < T_n + 1; y++) {
      fprintf(stdout, "% 4d", V[x][y]);
    }
    fprintf(stdout, "\n");
  }
#endif
  
  //tabulate all paths
  char V_b[S_n + 1][T_n + 1];
  memset(V_b, 0, (S_n + 1) * (T_n + 1));
  V_b[S_n][T_n] = SEEN;
  for (int x = S_n; x >= 0; x--) {
    for (int y = T_n; y >= 0; y--) {
      if (!(V_b[x][y] & SEEN)) continue;
      if (x == 0 && y == 0) break;
      if (x == 0) {
        V_b[x][y] = LEFT;
        V_b[x][y - 1] = SEEN;
      } else if (y == 0) {
        V_b[x][y] = UP;
        V_b[x - 1][y] = SEEN;
      } else {
        if (
          V[x - 1][y - 1] + match == V[x][y] && S[x - 1] == T[y - 1] ||
          V[x - 1][y - 1] + mismatch == V[x][y] && S[x - 1] != T[y - 1]
        ) {
          V_b[x][y] = UPLEFT;
          V_b[x - 1][y - 1] = SEEN;
        }
        if (V[x][y - 1] + indel == V[x][y]) {
          V_b[x][y] += LEFT;
          V_b[x][y - 1] = SEEN;
        }
        if (V[x - 1][y] + indel == V[x][y]) {
          V_b[x][y] += UP;
          V_b[x - 1][y] = SEEN;
        }
      }
    }
  }


#ifdef DEBUG
  for (int x = 0; x < S_n + 1; x++) {
    for (int y = 0; y < T_n + 1; y++) {
      if (x == 0 && y == 0) fprintf(stdout, "% 4c", '*');
      else {
        char directions[4] = {
          V_b[x][y] & LEFT      ? 'L' : '-',
          V_b[x][y] & UPLEFT    ? 'D' : '-',
          V_b[x][y] & UP        ? 'U' : '-',
          0
        };
        fprintf(stdout, "% 4s", directions);
      }
    }
    fprintf(stdout, "\n");
  }
#endif

  // create the alignment
  if (ret == NULL) return;
  char Sa[S_n + T_n + 1];
  char Ta[S_n + T_n + 1];
  uint32_t x = 0;
  uint32_t y = 0;
  uint32_t i = 0;
  while (x < S_n || y < T_n) {
    if (x == S_n) {
      Sa[i] = '_';
      Ta[i] = T[y];
      y++;
    } else if (y == T_n) {
      Sa[i] = S[x];
      Ta[i] = '_';
      x++;
    } else {
      if (V_b[x][y + 1] & LEFT) {
        Sa[i] = '_';
        Ta[i] = T[y];
        y++;
      } else if (V_b[x + 1][y + 1] & UPLEFT) {
        Sa[i] = S[x];
        Ta[i] = T[y];
        x++;
        y++;
      } else if (V_b[x + 1][y] & UP) {
        Sa[i] = S[x];
        Ta[i] = '_';
        x++;
      }
    }
    i++;
  }
  Sa[i] = 0;
  Ta[i] = 0;

  char * tmpret = malloc(strlen(Sa) + strlen(Ta) + 2);
  sprintf(tmpret, "%s\n%s", Sa, Ta);
  *ret = tmpret;
}


