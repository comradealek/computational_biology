/**********************************************************************
 * global alignment for match, mismatch, and indel scores, and a file *
 * myAlign.c                                                          *
 * Aleksandr Means                                                    *
 **********************************************************************/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

void globalAlignment(char *, char *, int, int, int, char **);

#define LEFT    0x4
#define UPLEFT  0x2
#define UP      0x1

int main(int argc, char ** argv) {
  // early return if the arguments aren't formatted correctly
  if (argc != 5) return 0;

  int match = atoi(argv[1]);
  int mismatch = atoi(argv[2]);
  int indel = atoi(argv[3]);

  char * s = NULL;   // the text string
  FILE * pFile = fopen(argv[4], "r"); // pointer to the given file
  if (pFile == NULL) {
    fprintf(stderr, "error reading file at %s\n", argv[4]);
    return 1;
  }

  fseek(pFile, 0L, SEEK_END);
  size_t fsize = ftell(pFile); // the size of the file
  fseek(pFile, 0L, SEEK_SET);

  // We will now read the file into the text string
  s = malloc(fsize);
  char * t = NULL;
  char * next = s; // pointer to the next position in the string to read the file line into

  while (!feof(pFile)) {
    // the upper bound to read characters into the text string
    size_t n = fsize - (next - s); 

    // read the next file line into the text string at 'next'
    getline(&next, &n, pFile);

    // find the next instance of \n, \r, >, or ';', and set that to next
    // This will have the effect of overwriting the string starting at any
    // of these characters. This will erase comments, and will remove the 
    // carriage returns or newline characters.
    next = strpbrk(next, "\n\r>;");

    // if the S string isn't defined and 
    if ((next[0] == '>' || next[0] == ';') && !t && s != next) {
      next[0] = 0;
      next += 1;
      t = next;
    }
  }
  
  // sets the final newline/carriage return to 0 if it exists.
  if (next) next[0] = 0;

  char * align = NULL;
  globalAlignment(s, t, match, mismatch, indel, &align);

  fprintf(stdout, "%s\n", align);
  free(align);
  free(s);
  return 0;
}

void globalAlignment(char * S, char * T, int match, int mismatch, int indel, char ** ret) {
  // get the number of characters in S and T
  size_t S_n = strlen(S);
  size_t T_n = strlen(T);

  // create the V matrix
  int V[S_n + 1][T_n + 1];
  for (int x = 0; x < S_n + 1; x++) {
    for (int y = 0; y < T_n + 1; y++) {
      if (x == 0 && y == 0) {
        V[x][y] = 0;
      } else if (x == 0) {
        V[x][y] = V[x][y - 1] + indel;
      } else if (y == 0) {
        V[x][y] = V[x - 1][y] + indel;
      } else {
        int u = V[x - 1][y] + indel;
        int l = V[x][y - 1] + indel;
        int ul = V[x - 1][y - 1] +  (S[x - 1] == T[y - 1] ? match : mismatch);
        V[x][y] = (u > l ? (u > ul ? u : ul) : (l > ul ? l : ul));
      }
    }
  }

#ifdef DEBUG
  fprintf(stdout, " % 4c", '_');
  for (int y = 0; y < T_n + 1; y++) 
    fprintf(stdout, "% 4c", T[y]);
  fprintf(stdout, "\n");
  for (int x = 0; x < S_n + 1; x++) {
    if (x == 0) fprintf(stdout, "_");
    else fprintf(stdout, "%c", S[x - 1]);
    for (int y = 0; y < T_n + 1; y++) {
      fprintf(stdout, "% 4d", V[x][y]);
    }
    fprintf(stdout, "\n");
  }
#endif
  
  // backtrace the path
  char V_b[S_n + 1][T_n + 1];
  memset(V_b, 0, (S_n + 1) * (T_n + 1));
  int x = S_n;
  int y = T_n;
  int count = 0;
  while (x != 0 || y != 0) {
    count++;
    if (x == 0) {
      V_b[x][y] = LEFT;
      y -= 1;
    } else if (y == 0) {
      V_b[x][y] = UP;
      x -= 1;
    } else {
      if ( 
        V[x - 1][y - 1] + match == V[x][y]  && S[x - 1] == T[y - 1] || 
        V[x - 1][y - 1] + mismatch == V[x][y] && S[x - 1] != T[y - 1]
      ) {
        V_b[x][y] = UPLEFT;
        x -= 1;
        y -= 1;
      } else if ( V[x][y - 1] + indel == V[x][y] ) {
        V_b[x][y] = LEFT;
        y -= 1;
      } else if (V[x - 1][y] + indel == V[x][y]) {
        V_b[x][y] = UP;
        x -= 1;
      }
    }
  }

#ifdef DEBUG
  fprintf(stdout, "\n%d\n", count);
  for (int x = 0; x < S_n + 1; x++) {
    for (int y = 0; y < T_n + 1; y++) {
      if (x == 0 && y == 0) fprintf(stdout, "% 2c", '*');
      else fprintf(stdout, "% 2c", (V_b[x][y] & UP ? 'U' : V_b[x][y] & LEFT ? 'L' : V_b[x][y] & UPLEFT ? 'D' : '-'));
    }
    fprintf(stdout, "\n");
  }
#endif

  // create the alignment
  x = 0;
  y = 0;
  char * align = (char *) malloc((2 * count + 1) * sizeof(char));
  align[count] = '\n';
  uint32_t i = 0;
  while (x < S_n || y < T_n) {
    if (V_b[x][y + 1] != 0) {
      y += 1;
      align[i] = '_';
      align[i + 1 + count] = T[y - 1];
    } else if (V_b[x + 1][y] != 0) {
      x += 1;
      align[i] = S[x - 1];
      align[i + 1 + count] = '_';
    } else {
      x += 1;
      y += 1;
      align[i] = S[x - 1];
      align[i + 1 + count] = T[y - 1];
    }
    i++;
  }
  *ret = align;


}
